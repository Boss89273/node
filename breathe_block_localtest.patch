Index: plugins/dex/order/keeper_recovery.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- plugins/dex/order/keeper_recovery.go	(revision Local Version)
+++ plugins/dex/order/keeper_recovery.go	(revision Shelved Version)
@@ -3,6 +3,7 @@
 import (
 	"bytes"
 	"compress/zlib"
+	"encoding/hex"
 	"fmt"
 	"io"
 	"sort"
@@ -55,7 +56,7 @@
 		return err
 	}
 	bytes = b.Bytes()
-	bnclog.Debug(fmt.Sprintf("compressAndSave key: %s, value: %v", key, bytes))
+	bnclog.Debug(fmt.Sprintf("compressAndSave key: %s, value: %s", key, hex.EncodeToString(bytes)))
 	kv.Set([]byte(key), bytes)
 	w.Close()
 	return nil
@@ -68,6 +69,7 @@
 	for pair, eng := range kp.engines {
 		buys, sells := eng.Book.GetAllLevels()
 		snapshot := OrderBookSnapshot{Buys: buys, Sells: sells, LastTradePrice: eng.LastTradePrice}
+		logger.Debug("snapshot orderbook last trade price", "price", eng.LastTradePrice)
 		key := genOrderBookSnapshotKey(height, pair)
 		effectedStoreKeys = append(effectedStoreKeys, key)
 		err := compressAndSave(snapshot, kp.cdc, key, kvstore)
@@ -89,6 +91,7 @@
 	msgs := make([]OrderInfo, len(msgKeys), len(msgKeys))
 	for i, key := range msgKeys {
 		msgs[i] = *kp.allOrders[idSymbolMap[key]][key]
+		logger.Debug(fmt.Sprintf("snapshot active order: %s", msgs[i].String()))
 	}
 
 	snapshot := ActiveOrders{Orders: msgs}
@@ -126,6 +129,7 @@
 
 		key := genOrderBookSnapshotKey(height, symbol)
 		bz := kvStore.Get([]byte(key))
+		logger.Debug("orderbook snapshot", "key", key, "bytes", hex.EncodeToString(bz))
 		if bz == nil {
 			// maybe that is a new listed pair
 			logger.Info("Pair is newly listed, no order book snapshot was saved", "pair", key)
@@ -153,6 +157,7 @@
 	}
 	key := genActiveOrdersSnapshotKey(height)
 	bz := kvStore.Get([]byte(key))
+	logger.Debug("active orders snapshot", "key", key, "bytes", hex.EncodeToString(bz))
 	if bz == nil {
 		logger.Info("Pair is newly listed, no active order snapshot was saved", "pair", key)
 		return height, nil
@@ -164,12 +169,14 @@
 		panic(fmt.Sprintf("failed to unmarshal snapshort for active order [%s]", key))
 	}
 	io.Copy(&bw, r)
+	bytes := bw.Bytes()
 	var ao ActiveOrders
-	err = kp.cdc.UnmarshalBinary(bw.Bytes(), &ao)
+	err = kp.cdc.UnmarshalBinary(bytes, &ao)
 	if err != nil {
 		panic(fmt.Sprintf("failed to unmarshal snapshort for active orders [%s]", key))
 	}
 	for _, m := range ao.Orders {
+		bnclog.Debug("load active order from snapshot", "order", m.String())
 		orderHolder := m
 		kp.allOrders[m.Symbol][m.Id] = &orderHolder
 		if kp.CollectOrderInfoForPublish {
Index: plugins/dex/matcheng/orderbook.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- plugins/dex/matcheng/orderbook.go	(revision Local Version)
+++ plugins/dex/matcheng/orderbook.go	(revision Shelved Version)
@@ -6,6 +6,8 @@
 	"fmt"
 
 	bt "github.com/google/btree"
+
+	"github.com/BiJie/BinanceChain/common/log"
 )
 
 // OrderBookInterface is a generic sequenced order to quickly get the spread to match.
@@ -162,12 +164,16 @@
 func (ob *OrderBookOnULList) GetAllLevels() ([]PriceLevel, []PriceLevel) {
 	buys := make([]PriceLevel, 0, ob.buyQueue.capacity)
 	sells := make([]PriceLevel, 0, ob.sellQueue.capacity)
+	log.Debug("snapshot orders buys queue capacity", "capacity", ob.buyQueue.capacity)
 	ob.buyQueue.Iterate(ob.buyQueue.capacity,
 		func(p *PriceLevel) {
+			log.Debug("append buys to orderbook", "pricelevel", p.String())
 			buys = append(buys, *p)
 		})
+	log.Debug("snapshot orders sells queue capacity", "capacity", ob.sellQueue.capacity)
 	ob.sellQueue.Iterate(ob.sellQueue.capacity,
 		func(p *PriceLevel) {
+			log.Debug("append sells to orderbook", "pricelevel", p.String())
 			sells = append(sells, *p)
 		})
 	return buys, sells
Index: app/app.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/app.go	(revision Local Version)
+++ app/app.go	(revision Shelved Version)
@@ -235,7 +235,8 @@
 	//future TODO: add failure info.
 	response := abci.ResponseEndBlock{}
 
-	if utils.SameDayInUTC(lastBlockTime, blockTime) || height == 1 {
+	if utils.SameDayInUTC(lastBlockTime, blockTime) && (height%2 != 0) {
+		//if utils.SameDayInUTC(lastBlockTime, blockTime) || height == 1 {
 		// only match in the normal block
 		app.Logger.Debug("normal block", "height", height)
 		if app.publicationConfig.PublishOrderUpdates && app.publisher.IsLive {
Index: plugins/ico/endblock.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- plugins/ico/endblock.go	(revision Local Version)
+++ plugins/ico/endblock.go	(revision Shelved Version)
@@ -2,7 +2,6 @@
 
 import (
 	"fmt"
-
 	sdk "github.com/cosmos/cosmos-sdk/types"
 )
 
Index: plugins/dex/order/msg.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- plugins/dex/order/msg.go	(revision Local Version)
+++ plugins/dex/order/msg.go	(revision Shelved Version)
@@ -211,6 +211,12 @@
 	TxHash           string
 }
 
+func (o OrderInfo) String() string {
+	return fmt.Sprintf(
+		"OrderInfo - id: %s, createdTimestamp: %d, cumQty: %d, txHash: %s",
+		o.Id, o.CreatedTimestamp, o.CumQty, o.TxHash)
+}
+
 // NewCancelOrderMsg constructs a new CancelOrderMsg
 func NewCancelOrderMsg(sender sdk.AccAddress, symbol, id, refId string) CancelOrderMsg {
 	return CancelOrderMsg{
